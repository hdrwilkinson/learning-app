---
description: Interacting with firebase or firestore in any way
globs: 
alwaysApply: false
---
# Firebase Best Practices

## Environment Strategy

| Stage | Purpose | Commands |
|----|---|----|
| **Local** | Local Emulator Suite for rapid development and testing. | `firebase emulators:start` |
| **Development** | Shared Firebase project for testing, QA, and collaboration. | `firebase use dev` |
| **Production** | Customer-facing production Firebase instance. | `firebase use prod` |

Maintain separate `.env.*` files per environment. Prefix browser-exposed variables with `NEXT_PUBLIC_`.

## Client vs Server Responsibilities

| Context | SDK | Notes |
|---|-----|----|
| **Browser / Next.js Client** | Modular Firebase Web SDK (v9+). | Tree-shakable and optimized. |
| **Cloud Functions** | Firebase Admin SDK. | Uses privileged access; do not deploy client-side. |

## Recommended Structure

```
services/firebase
│   ├── firebaseApp.ts     # initializeApp()
│   ├── firestore.ts       # getFirestore()
│   └── auth.ts            # getAuth()
│
functions/src
│   ├── adminApp.ts        # admin.initializeApp()
│   ├── api/               # HTTPS endpoints
│   ├── triggers/          # Firestore, Auth, Pub/Sub triggers
│   └── lib/               # shared helpers
```

## Cloud Functions

- Use Cloud Functions 2nd-gen (Node 20).
- Keep each function small, focused, and reusable.
- Deploy via `firebase deploy --only functions`.
- Test locally using the Emulator Suite: `firebase emulators:start --only functions`.

## Firestore Data Modelling

- Model data as top-level collections → documents → subcollections.
- Limit document size and avoid arrays that can grow indefinitely.
- Use subcollections for relational (1:n or n:n) structures.
- Define composite indexes explicitly using `firebase firestore:indexes`.

## Security Rules

- Always follow least privilege principle (`request.auth != null` checks).
- Validate data shape and ownership directly in security rules.
- Version control rules and test thoroughly with Rules Unit Testing library.

## Local Development and Testing

- Regularly use Firebase Emulator Suite for Firestore, Auth, and Functions.
- Seed emulator databases in Jest's `globalSetup`.
- Point SDK clients to emulator endpoints using:
  - `connectFirestoreEmulator`
  - `connectAuthEmulator`

## Firebase App Hosting and Next.js Integration

- **Frontend Deployment**: Firebase App Hosting automatically deploys Next.js apps on git push to configured branch
- **Backend Deployment**: Use Firebase CLI for functions, rules, and other backend services
- **Configuration**: Manage through `apphosting.yaml` for hosting and `firebase.json` for backend services

## Deployment Optimization

### Smart Deployment Commands

Use targeted deployment to avoid unnecessary rebuilds:

| Command | Purpose | When to Use |
|---------|---------|-------------|
| `npm run deploy:smart` | Intelligent backend deployment based on git changes | Daily development |
| `npm run deploy:functions` | Deploy only Cloud Functions | Functions-only changes |
| `npm run deploy:firestore` | Deploy only Firestore rules | Rules/indexes changes |
| `npm run deploy:storage` | Deploy only Storage rules | Storage rules changes |
| `npm run deploy:backend` | Deploy all backend services | Backend-only releases |

### Firebase App Hosting Behavior

**Frontend Deployment:**
- App Hosting automatically deploys on git push to live branch (configured in Firebase Console)
- No manual build/deploy commands needed for frontend changes
- Optimized for Next.js with automatic SSR and static generation

**Backend Services:**
- Functions, Firestore rules, and Storage rules deployed separately via Firebase CLI
- Use targeted deployments to avoid unnecessary rebuilds

### Functions Build Optimization

Functions include a `build:check` script that only rebuilds when source files change:
- Checks if `src/` files are newer than `lib/` directory
- Skips TypeScript compilation if no changes detected
- Reduces deployment time for functions-only changes

## Continuous Integration and Deployment (CI/CD)

| Step | Action |
|------|--------|
| Test | Run linting and unit tests with `npm run test`. |
| Frontend Deploy | Automatic via App Hosting on git push to live branch |
| Backend Deploy | Use `npm run deploy:smart` or `firebase deploy --project dev`. |

## Performance and Optimization

- Query only necessary document fields.
- Always paginate data retrieval (use `limit` and `startAfter`).
- Regularly review and remove unused indexes to optimize performance.
- Use targeted deployments to minimize rebuild time and costs.

## Backup and Monitoring

- Schedule regular backups using Cloud Scheduler combined with `gcloud`.
- Monitor application health via Firebase Crashlytics (client-side) and Cloud Monitoring (server-side).